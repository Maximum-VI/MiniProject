/* eslint max-len: 0 */

import {
  eat,
  lookaheadType,
  lookaheadTypeAndKeyword,
  match,
  next,
  popTypeContext,
  pushTypeContext,

} from "../tokenizer/index";
import {ContextualKeyword} from "../tokenizer/keywords";
import {TokenType, TokenType as tt} from "../tokenizer/types";
import {input, state} from "../traverser/base";
import {
  baseParseMaybeAssign,
  baseParseSubscript,
  baseParseSubscripts,
  parseArrow,
  parseArrowExpression,
  parseCallExpressionArguments,
  parseExprAtom,
  parseExpression,
  parseFunctionBody,
  parseIdentifier,
  parseLiteral,

} from "../traverser/expression";
import {
  baseParseExportStar,
  parseExport,
  parseExportFrom,
  parseExportSpecifiers,
  parseFunctionParams,
  parseImport,
  parseStatement,
} from "../traverser/statement";
import {
  canInsertSemicolon,
  eatContextual,
  expect,
  expectContextual,
  isContextual,
  isLookaheadContextual,
  semicolon,
  unexpected,
} from "../traverser/util";

function isMaybeDefaultImport(lookahead) {
  return (
    (lookahead.type === tt.name || !!(lookahead.type & TokenType.IS_KEYWORD)) &&
    lookahead.contextualKeyword !== ContextualKeyword._from
  );
}

function flowParseTypeInitialiser(tok) {
  const oldIsType = pushTypeContext(0);
  expect(tok || tt.colon);
  flowParseType();
  popTypeContext(oldIsType);
}

function flowParsePredicate() {
  expect(tt.modulo);
  expectContextual(ContextualKeyword._checks);
  if (eat(tt.parenL)) {
    parseExpression();
    expect(tt.parenR);
  }
}

function flowParseTypeAndPredicateInitialiser() {
  const oldIsType = pushTypeContext(0);
  expect(tt.colon);
  if (match(tt.modulo)) {
    flowParsePredicate();
  } else {
    flowParseType();
    if (match(tt.modulo)) {
      flowParsePredicate();
    }
  }
  popTypeContext(oldIsType);
}

function flowParseDeclareClass() {
  next();
  flowParseInterfaceish(/* isClass */ true);
}

function flowParseDeclareFunction() {
  next();
  parseIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  expect(tt.parenL);
  flowParseFunctionTypeParams();
  expect(tt.parenR);

  flowParseTypeAndPredicateInitialiser();

  semicolon();
}

function flowParseDeclare() {
  if (match(tt._class)) {
    flowParseDeclareClass();
  } else if (match(tt._function)) {
    flowParseDeclareFunction();
  } else if (match(tt._var)) {
    flowParseDeclareVariable();
  } else if (eatContextual(ContextualKeyword._module)) {
    if (eat(tt.dot)) {
      flowParseDeclareModuleExports();
    } else {
      flowParseDeclareModule();
    }
  } else if (isContextual(ContextualKeyword._type)) {
    flowParseDeclareTypeAlias();
  } else if (isContextual(ContextualKeyword._opaque)) {
    flowParseDeclareOpaqueType();
  } else if (isContextual(ContextualKeyword._interface)) {
    flowParseDeclareInterface();
  } else if (match(tt._export)) {
    flowParseDeclareExportDeclaration();
  } else {
    unexpected();
  }
}

function flowParseDeclareVariable() {
  next();
  flowParseTypeAnnotatableIdentifier();
  semicolon();
}

function flowParseDeclareModule() {
  if (match(tt.string)) {
    parseExprAtom();
  } else {
    parseIdentifier();
  }

  expect(tt.braceL);
  while (!match(tt.braceR) && !state.error) {
    if (match(tt._import)) {
      next();
      parseImport();
    } else {
      unexpected();
    }
  }
  expect(tt.braceR);
}

function flowParseDeclareExportDeclaration() {
  expect(tt._export);

  if (eat(tt._default)) {
    if (match(tt._function) || match(tt._class)) {
      // declare export default class ...
      // declare export default function ...
      flowParseDeclare();
    } else {
      // declare export default [type];
      flowParseType();
      semicolon();
    }
  } else if (
    match(tt._var) || // declare export var ...
    match(tt._function) || // declare export function ...
    match(tt._class) || // declare export class ...
    isContextual(ContextualKeyword._opaque) // declare export opaque ..
  ) {
    flowParseDeclare();
  } else if (
    match(tt.star) || // declare export * from ''
    match(tt.braceL) || // declare export {} ...
    isContextual(ContextualKeyword._interface) || // declare export interface ...
    isContextual(ContextualKeyword._type) || // declare export type ...
    isContextual(ContextualKeyword._opaque) // declare export opaque type ...
  ) {
    parseExport();
  } else {
    unexpected();
  }
}

function flowParseDeclareModuleExports() {
  expectContextual(ContextualKeyword._exports);
  flowParseTypeAnnotation();
  semicolon();
}

function flowParseDeclareTypeAlias() {
  next();
  flowParseTypeAlias();
}

function flowParseDeclareOpaqueType() {
  next();
  flowParseOpaqueType(true);
}

function flowParseDeclareInterface() {
  next();
  flowParseInterfaceish();
}

// Interfaces

function flowParseInterfaceish(isClass = false) {
  flowParseRestrictedIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  if (eat(tt._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (!isClass && eat(tt.comma));
  }

  if (isContextual(ContextualKeyword._mixins)) {
    next();
    do {
      flowParseInterfaceExtends();
    } while (eat(tt.comma));
  }

  if (isContextual(ContextualKeyword._implements)) {
    next();
    do {
      flowParseInterfaceExtends();
    } while (eat(tt.comma));
  }

  flowParseObjectType(isClass, false, isClass);
}

function flowParseInterfaceExtends() {
  flowParseQualifiedTypeIdentifier(false);
  if (match(tt.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseInterface() {
  flowParseInterfaceish();
}

function flowParseRestrictedIdentifier() {
  parseIdentifier();
}

function flowParseTypeAlias() {
  flowParseRestrictedIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  flowParseTypeInitialiser(tt.eq);
  semicolon();
}

function flowParseOpaqueType(declare) {
  expectContextual(ContextualKeyword._type);
  flowParseRestrictedIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  // Parse the supertype
  if (match(tt.colon)) {
    flowParseTypeInitialiser(tt.colon);
  }

  if (!declare) {
    flowParseTypeInitialiser(tt.eq);
  }
  semicolon();
}

function flowParseTypeParameter() {
  flowParseVariance();
  flowParseTypeAnnotatableIdentifier();

  if (eat(tt.eq)) {
    flowParseType();
  }
}

export function flowParseTypeParameterDeclaration() {
  const oldIsType = pushTypeContext(0);
  // istanbul ignore else: this condition is already checked at all call sites
  if (match(tt.lessThan) || match(tt.typeParameterStart)) {
    next();
  } else {
    unexpected();
  }

  do {
    flowParseTypeParameter();
    if (!match(tt.greaterThan)) {
      expect(tt.comma);
    }
  } while (!match(tt.greaterThan) && !state.error);
  expect(tt.greaterThan);
  popTypeContext(oldIsType);
}

function flowParseTypeParameterInstantiation() {
  const oldIsType = pushTypeContext(0);
  expect(tt.lessThan);
  while (!match(tt.greaterThan) && !state.error) {
    flowParseType();
    if (!match(tt.greaterThan)) {
      expect(tt.comma);
    }
  }
  expect(tt.greaterThan);
  popTypeContext(oldIsType);
}

function flowParseInterfaceType() {
  expectContextual(ContextualKeyword._interface);
  if (eat(tt._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (eat(tt.comma));
  }
  flowParseObjectType(false, false, false);
}

function flowParseObjectPropertyKey() {
  if (match(tt.num) || match(tt.string)) {
    parseExprAtom();
  } else {
    parseIdentifier();
  }
}

function flowParseObjectTypeIndexer() {
  // Note: bracketL has already been consumed
  if (lookaheadType() === tt.colon) {
    flowParseObjectPropertyKey();
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
  expect(tt.bracketR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeInternalSlot() {
  // Note: both bracketL have already been consumed
  flowParseObjectPropertyKey();
  expect(tt.bracketR);
  expect(tt.bracketR);
  if (match(tt.lessThan) || match(tt.parenL)) {
    flowParseObjectTypeMethodish();
  } else {
    eat(tt.question);
    flowParseTypeInitialiser();
  }
}

function flowParseObjectTypeMethodish() {
  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  expect(tt.parenL);
  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {
    flowParseFunctionTypeParam();
    if (!match(tt.parenR)) {
      expect(tt.comma);
    }
  }

  if (eat(tt.ellipsis)) {
    flowParseFunctionTypeParam();
  }
  expect(tt.parenR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeCallProperty() {
  flowParseObjectTypeMethodish();
}

function flowParseObjectType(allowStatic, allowExact, allowProto) {
  let endDelim;
  if (allowExact && match(tt.braceBarL)) {
    expect(tt.braceBarL);
    endDelim = tt.braceBarR;
  } else {
    expect(tt.braceL);
    endDelim = tt.braceR;
  }

  while (!match(endDelim) && !state.error) {
    if (allowProto && isContextual(ContextualKeyword._proto)) {
      const lookahead = lookaheadType();
      if (lookahead !== tt.colon && lookahead !== tt.question) {
        next();
        allowStatic = false;
      }
    }
    if (allowStatic && isContextual(ContextualKeyword._static)) {
      const lookahead = lookaheadType();
      if (lookahead !== tt.colon && lookahead !== tt.question) {
        next();
      }
    }

    flowParseVariance();

    if (eat(tt.bracketL)) {
      if (eat(tt.bracketL)) {
        flowParseObjectTypeInternalSlot();
      } else {
        flowParseObjectTypeIndexer();
      }
    } else if (match(tt.parenL) || match(tt.lessThan)) {
      flowParseObjectTypeCallProperty();
    } else {
      if (isContextual(ContextualKeyword._get) || isContextual(ContextualKeyword._set)) {
        const lookahead = lookaheadType();
        if (lookahead === tt.name || lookahead === tt.string || lookahead === tt.num) {
          next();
        }
      }

      flowParseObjectTypeProperty();
    }

    flowObjectTypeSemicolon();
  }

  expect(endDelim);
}

function flowParseObjectTypeProperty() {
  if (match(tt.ellipsis)) {
    expect(tt.ellipsis);
    if (!eat(tt.comma)) {
      eat(tt.semi);
    }
    // Explicit inexact object syntax.
    if (match(tt.braceR)) {
      return;
    }
    flowParseType();
  } else {
    flowParseObjectPropertyKey();
    if (match(tt.lessThan) || match(tt.parenL)) {
      // This is a method property
      flowParseObjectTypeMethodish();
    } else {
      eat(tt.question);
      flowParseTypeInitialiser();
    }
  }
}

function flowObjectTypeSemicolon() {
  if (!eat(tt.semi) && !eat(tt.comma) && !match(tt.braceR) && !match(tt.braceBarR)) {
    unexpected();
  }
}

function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
  if (!initialIdAlreadyParsed) {
    parseIdentifier();
  }
  while (eat(tt.dot)) {
    parseIdentifier();
  }
}

function flowParseGenericType() {
  flowParseQualifiedTypeIdentifier(true);
  if (match(tt.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseTypeofType() {
  expect(tt._typeof);
  flowParsePrimaryType();
}

function flowParseTupleType() {
  expect(tt.bracketL);
  // We allow trailing commas
  while (state.pos < input.length && !match(tt.bracketR)) {
    flowParseType();
    if (match(tt.bracketR)) {
      break;
    }
    expect(tt.comma);
  }
  expect(tt.bracketR);
}

function flowParseFunctionTypeParam() {
  const lookahead = lookaheadType();
  if (lookahead === tt.colon || lookahead === tt.question) {
    parseIdentifier();
    eat(tt.question);
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
}

function flowParseFunctionTypeParams() {
  while (!match(tt.parenR) && !match(tt.ellipsis) && !state.error) {
    flowParseFunctionTypeParam();
    if (!match(tt.parenR)) {
      expect(tt.comma);
    }
  }
  if (eat(tt.ellipsis)) {
    flowParseFunctionTypeParam();
  }
}

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
function flowParsePrimaryType() {
  let isGroupedType = false;
  const oldNoAnonFunctionType = state.noAnonFunctionType;

  switch (state.type) {
    case tt.name: {
      if (isContextual(ContextualKeyword._interface)) {
        flowParseInterfaceType();
        return;
      }
      parseIdentifier();
      flowParseGenericType();
      return;
    }

    case tt.braceL:
      flowParseObjectType(false, false, false);
      return;

    case tt.braceBarL:
      flowParseObjectType(false, true, false);
      return;

    case tt.bracketL:
      flowParseTupleType();
      return;

    case tt.lessThan:
      flowParseTypeParameterDeclaration();
      expect(tt.parenL);
      flowParseFunctionTypeParams();
      expect(tt.parenR);
      expect(tt.arrow);
      flowParseType();
      return;

    case tt.parenL:
      next();

      // Check to see if this is actually a grouped type
      if (!match(tt.parenR) && !match(tt.ellipsis)) {
        if (match(tt.name)) {
          const token = lookaheadType();
          isGroupedType = token !== tt.question && token !== tt.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        state.noAnonFunctionType = false;
        flowParseType();
        state.noAnonFunctionType = oldNoAnonFunctionType;

        // A `,` or a `) =>` means this is an anonymous function type
        if (
          state.noAnonFunctionType ||
          !(match(tt.comma) || (match(tt.parenR) && lookaheadType() === tt.arrow))
        ) {
          expect(tt.parenR);
          return;
        } else {
          // Eat a comma if there is one
          eat(tt.comma);
        }
      }

      flowParseFunctionTypeParams();

      expect(tt.parenR);
      expect(tt.arrow);
      flowParseType();
      return;

    case tt.minus:
      next();
      parseLiteral();
      return;

    case tt.string:
    case tt.num:
    case tt._true:
    case tt._false:
    case tt._null:
    case tt._this:
    case tt._void:
    case tt.star:
      next();
      return;

    default:
      if (state.type === tt._typeof) {
        flowParseTypeofType();
        return;
      } else if (state.type & TokenType.IS_KEYWORD) {
        next();
        state.tokens[state.tokens.length - 1].type = tt.name;
        return;
      }
  }

  unexpected();
}

function flowParsePostfixType() {
  flowParsePrimaryType();
  while (!canInsertSemicolon() && (match(tt.bracketL) || match(tt.questionDot))) {
    eat(tt.questionDot);
    expect(tt.bracketL);
    if (eat(tt.bracketR)) {
      // Array type
    } else {
      // Indexed access type
      flowParseType();
      expect(tt.bracketR);
    }
  }
}

function flowParsePrefixType() {
  if (eat(tt.question)) {
    flowParsePrefixType();
  } else {
    flowParsePostfixType();
  }
}

function flowParseAnonFunctionWithoutParens() {
  flowParsePrefixType();
  if (!state.noAnonFunctionType && eat(tt.arrow)) {
    flowParseType();
  }
}

function flowParseIntersectionType() {
  eat(tt.bitwiseAND);
  flowParseAnonFunctionWithoutParens();
  while (eat(tt.bitwiseAND)) {
    flowParseAnonFunctionWithoutParens();
  }
}

function flowParseUnionType() {
  eat(tt.bitwiseOR);
  flowParseIntersectionType();
  while (eat(tt.bitwiseOR)) {
    flowParseIntersectionType();
  }
}

function flowParseType() {
  flowParseUnionType();
}

export function flowParseTypeAnnotation() {
  flowParseTypeInitialiser();
}

function flowParseTypeAnnotatableIdentifier() {
  parseIdentifier();
  if (match(tt.colon)) {
    flowParseTypeAnnotation();
  }
}

export function flowParseVariance() {
  if (match(tt.plus) || match(tt.minus)) {
    next();
    state.tokens[state.tokens.length - 1].isType = true;
  }
}

// ==================================
// Overrides
// ==================================

export function flowParseFunctionBodyAndFinish(funcContextId) {
  // For arrow functions, `parseArrow` handles the return type itself.
  if (match(tt.colon)) {
    flowParseTypeAndPredicateInitialiser();
  }

  parseFunctionBody(false, funcContextId);
}

export function flowParseSubscript(
  startTokenIndex,
  noCalls,
  stopState,
) {
  if (match(tt.questionDot) && lookaheadType() === tt.lessThan) {
    if (noCalls) {
    ˜      ÇÄ     0       ™D    å;oAj‚Û              X < M i c r o s o f t - W i n d o w s - P a r t i t i o n % 4 D i a g n o s t i c . e v t x     °      âÄ     0     ˜ ™D    DžqAj‚Û              r < M i c r o s o f t - W i n d o w s - V o l u m e S n a p s h o t - D r i v e r % 4 O p e r a t i o n a l . e v t x          ¬Ä     0     H™D    DžqAj‚Û              b < M i c r o s o f t - W i n d o w s - C o d e I n t e g r i t y % 4 O p e r a t i o n a l . e v t x   X      \Ä     Z     è™D    « tAj‚Û€               < N e t C o r e . e t l       ¨      s     0     @™D    XÅxAj‚Û              f < M i c r o s o f t - W i n d o w s - H y p e r - V - V m S w i t c h - O p e r a t i o n a l . e v t x              ¼Ä     0     è™D    ¢'{Aj‚Û              ` < M i c r o s o f t - W i n d o w s - K e r n e l - P n P % 4 C o n f i g u r a t i o n . e v t x     €      4     ÉÅ     ˆ™D    ±„Aj‚Û               > < S t a t e R e p o s i t o r y - M a c h i n e . s r d - s h m       €      4     ÉÅ     ™D    ±„Aj‚Û               > < S t a t e R e p o s i t o r y - M a c h i n e . s r d - s h m       p      F~    Ö;	     ˆ™D    Åu‰Aj‚Û               . < ~ F o n t C a c h e - S - 1 - 5 - 1 8 . d a t       €      ç¯    ;	     ø™D    Åu‰Aj‚Û               > < ~ F o n t C a c h e - F o n t S e t - S - 1 - 5 - 1 8 . d a t       p      F~    Ö;	     x™D    Åu‰Aj‚Û              . < ~ F o n t C a c h e - S - 1 - 5 - 1 8 . d a t       €      ç¯    ;	     è™D    Åu‰Aj‚Û              > < ~ F o n t C a c h e - F o n t S e t - S - 1 - 5 - 1 8 . d a t       €      `    Å     h™D    ¦Ø‹Aj‚Û               D < S t a t e R e p o s i t o r y - D e p l o y m e n t . s r d - s h m €      `    Å     è™D    ¦Ø‹Aj‚Û               D < S t a t e R e p o s i t o r y - D e p l o y m e n t . s r d - s h m €      4     ÉÅ     h™D    ¦Ø‹Aj‚Û  €            > < S t a t e R e p o s i t o r y - M a c h i n e . s r d - s h m       €      4     ÉÅ     è™D    ¦Ø‹Aj‚Û               > < S t a t e R e p o s i t o r y - M a c h i n e . s r d - s h m       €      4     ÉÅ     h™D    ¦Ø‹Aj‚Û               > < S t a t e R e p o s i t o r y - M a c h i n e . s r d - s h m       x      ð_    Å     è™D    ¦Ø‹Aj‚Û               6 < S t a t e R e p o s i t o r y - M a c h i n e . s r d       €      3     ËÅ     `	™D    ¦Ø‹Aj‚Û               > < S t a t e R e p o s i t o r y - M a c h i n e . s r d - w a l       €      4     ÉÅ     à	™D    ¦Ø‹Aj‚Û  €            > < S t a t e R e p o s i t o r y - M a c h i n e . s r d - s h m       €      3     ËÅ     `
™D    ¦Ø‹Aj‚Û  €            > < S t a t e R e p o s i t o r y - M a c h i n e . s r d - w a l       x      ð_    Å     à
™D    ¦Ø‹Aj‚Û  €            6 < S t a t e R e p o s i t o r y - M a c h i n e . s r d       €      `    Å     X™D    ‚:ŽAj‚Û  €            D < S t a t e R e p o s i t o r y - D e p l o y m e n t . s r d - s h m €      `    Å     Ø™D    ‚:ŽAj‚Û               D < S t a t e R e p o s i t o r y - D e p l o y m e n t . s r d - s h m €      `    Å     X™D    ‚:ŽAj‚Û               D < S t a t e R e p o s i t o r y - D e p l o y m e n t . s r d - s h m x      
`    Å     Ø™D    ‚:ŽAj‚Û               < < S t a t e R e p o s i t o r y - D e p l o y m e n t . s r d €      `    Å     P™D    ‚:ŽAj‚Û               D < S t a t e R e p o s i t o r y - D e p l o y m e n t . s r d - w a l €      `    Å     Ð™D    ‚:ŽAj‚Û  €            D < S t a t e R e p o s i t o r y - D e p l o y m e n t . s r d - s h m €      `    Å     P™D    ÞœAj‚Û  €            D < S t a t e R e p o s i t o r y - D e p l o y m e n t . s r d - w a l x      
`    Å     Ð™D    ÞœAj‚Û  €            < < S t a t e R e p o s i t o r y - D e p l o y m e n t . s r d €      `    Å     H™D    ÞœAj‚Û               D < S t a t e R e p o s i t o r y - D e p l o y m e n t . s r d - s h m                                                         €      `    Å      ™D    ÞœAj‚Û               D < S t a t e R e p o s i t o r y - D e p l o y m e n t . s r d - s h m €      4     ÉÅ     €™D    ÞœAj‚Û               > < S t a t e R e p o s i t o r y - M a c h i n e . s r d - s h m       €      4     ÉÅ      ™D    ÞœAj‚Û               > < S t a t e R e p o s i t o r y - M a c h i n e . s r d - s h m       X      (…    ê     €™D    …a•Aj‚Û €               < s e r v i c e . 0 . e t l   X      (…    ê     Ø™D    …a•Aj‚Û€               < s e r v i c e . 0 . e t l   X      ˜    V     0™D    …a•Aj‚Û                < s e t u p a c t . l o g     `      RÄ     [     ˆ™D    …a•Aj‚Û                 < E t w R T D i a g L o g . e t l     X      ˜    V     è™D    …a•Aj‚Û  €             < s e t u p a c t . l o g     X      ˜    V     @™D    ðÃ—Aj‚Û                < s e t u p a c t . l o g     X      ˜    V     ˜™D    ðÃ—Aj‚Û  €             < s e t u p a c t . l o g     °      °    xñ	    ð™D    ðÃ—Aj‚Û           &   p < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . b l f     °      °    ò	     ™D    ðÃ—Aj‚Û           &   p < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . b l f     °      °    xñ	    P™D    ðÃ—Aj‚Û          &   p < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . b l f     °      °    Jð	     ™D    ðÃ—Aj‚Û           &   p < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . b l f     °      °    ò	    °™D    ðÃ—Aj‚Û          &   p < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . b l f     °      °    Jð	    `™D    ðÃ—Aj‚Û          &   p < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . b l f     °      Â{    ò	    ™D    ðÃ—Aj‚Û           &   p < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . b l f     °      °    xñ	    À™D    ðÃ—Aj‚Û          &   p < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . b l f     °      Â{    ò	    p™D    ðÃ—Aj‚Û          &   p < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . b l f     °      °    ò	     ™D    [&šAj‚Û          &   p < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . b l f     °      °    Jð	    Ð™D    [&šAj‚Û          &   p < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . b l f     À      Ã{    xñ	    €™D    [&šAj‚Û           &   „ < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . 0 . r e g t r a n s - m s °      Â{    ò	    @™D    [&šAj‚Û          &   p < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . b l f     À      Ã{    xñ	    ð™D    [&šAj‚Û          &   „ < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . 0 . r e g t r a n s - m s À      ê{    ò	    °™D    [&šAj‚Û           &   „ < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . 0 . r e g t r a n s - m s À      ê{    ò	    p™D    [&šAj‚Û          &   „ < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . 0 . r e g t r a n s - m s À      ï{    Jð	    0™D    ºˆœAj‚Û           &   „ < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . 0 . r e g t r a n s - m s                 À      ï{    Jð	      ™D    ºˆœAj‚Û          &   „ < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . 0 . r e g t r a n s - m s À      ó{    ò	    À ™D    ºˆœAj‚Û           &   „ < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . 0 . r e g t r a n s - m s À      ó{    ò	    €!™D    ºˆœAj‚Û          &   „ < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . 0 . r e g t r a n s - m s X      ˜    V     @"™D    ºˆœAj‚Û                < s e t u p a c t . l o g     À      õ{    xñ	    ˜"™D    ºˆœAj‚Û           &   „ < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . 1 . r e g t r a n s - m s À      õ{    xñ	    X#™D    \ëžAj‚Û          &   „ < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . 1 . r e g t r a n s - m s À      ö{    ò	    $™D    \ëžAj‚Û           &   „ < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . 1 . r e g t r a n s - m s X      ˜    V     Ø$™D    \ëžAj‚Û  €             < s e t u p a c t . l o g     À      ö{    ò	    0%™D    \ëžAj‚Û          &   „ < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . 1 . r e g t r a n s - m s X      ˜    V     ð%™D    \ëžAj‚Û                < s e t u p a c t . l o g     À      þ{    ò	    H&™D    \ëžAj‚Û           &   „ < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . 1 . r e g t r a n s - m s À      ø{    Jð	    '™D    FM¡Aj‚Û           &   „ < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . 1 . r e g t r a n s - m s À      þ{    ò	    È'™D    FM¡Aj‚Û          &   „ < N T U S E R . D A T { 5 3 b 3 9 e 8 7 - 1 8 c 4 - 1 1 e a - a 8 1 1 - 0 0 0 d 3 a a 4 6 9 2 b } . T x R . 1 . r e g t r a n s - m s X      ˜    V     ˆ(™D    FM¡Aj‚Û  €             < s e t u p a c t . l o g     À      ø{    Jð	    à(™D    FM¡Aj‚