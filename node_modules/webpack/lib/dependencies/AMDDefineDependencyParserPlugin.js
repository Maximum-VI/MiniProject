/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const RuntimeGlobals = require("../RuntimeGlobals");
const AMDDefineDependency = require("./AMDDefineDependency");
const AMDRequireArrayDependency = require("./AMDRequireArrayDependency");
const AMDRequireContextDependency = require("./AMDRequireContextDependency");
const AMDRequireItemDependency = require("./AMDRequireItemDependency");
const ConstDependency = require("./ConstDependency");
const ContextDependencyHelpers = require("./ContextDependencyHelpers");
const DynamicExports = require("./DynamicExports");
const LocalModuleDependency = require("./LocalModuleDependency");
const { addLocalModule, getLocalModule } = require("./LocalModulesHelpers");

/** @typedef {import("estree").ArrowFunctionExpression} ArrowFunctionExpression */
/** @typedef {import("estree").CallExpression} CallExpression */
/** @typedef {import("estree").Expression} Expression */
/** @typedef {import("estree").FunctionExpression} FunctionExpression */
/** @typedef {import("estree").Identifier} Identifier */
/** @typedef {import("estree").Literal} Literal */
/** @typedef {import("estree").MemberExpression} MemberExpression */
/** @typedef {import("estree").ObjectExpression} ObjectExpression */
/** @typedef {import("estree").SimpleCallExpression} SimpleCallExpression */
/** @typedef {import("estree").SpreadElement} SpreadElement */
/** @typedef {import("../../declarations/WebpackOptions").JavascriptParserOptions} JavascriptParserOptions */
/** @typedef {import("../Dependency").DependencyLocation} DependencyLocation */
/** @typedef {import("../javascript/BasicEvaluatedExpression")} BasicEvaluatedExpression */
/** @typedef {import("../javascript/JavascriptParser")} JavascriptParser */
/** @typedef {import("../javascript/JavascriptParser").Range} Range */

/**
 * @param {Expression | SpreadElement} expr expression
 * @returns {expr is CallExpression} true if it's a bound function expression
 */
const isBoundFunctionExpression = expr => {
	if (expr.type !== "CallExpression") return false;
	if (expr.callee.type !== "MemberExpression") return false;
	if (expr.callee.computed) return false;
	if (expr.callee.object.type !== "FunctionExpression") return false;
	if (expr.callee.property.type !== "Identifier") return false;
	if (expr.callee.property.name !== "bind") return false;
	return true;
};

/** @typedef {FunctionExpression | ArrowFunctionExpression} UnboundFunctionExpression */

/**
 * @param {Expression | SpreadElement} expr expression
 * @returns {expr is FunctionExpression | ArrowFunctionExpression} true when unbound function expression
 */
const isUnboundFunctionExpression = expr => {
	if (expr.type === "FunctionExpression") return true;
	if (expr.type === "ArrowFunctionExpression") return true;
	return false;
};

/**
 * @param {Expression | SpreadElement} expr expression
 * @returns {expr is FunctionExpression | ArrowFunctionExpression | CallExpression} true when callable
 */
const isCallable = expr => {
	if (isUnboundFunctionExpression(expr)) return true;
	if (isBoundFunctionExpression(expr)) return true;
	return false;
};

class AMDDefineDependencyParserPlugin {
	/**
	 * @param {JavascriptParserOptions} options parserOptions
	 */
	constructor(options) {
		this.options = options;
	}

	/**
	 * @param {JavascriptParser} parser the parser
	 * @returns {void}
	 */
	apply(parser) {
		parser.hooks.call
			.for("define")
			.tap(
				"AMDDefineDependencyParserPlugin",
				this.processCallDefine.bind(this, parser)
			);
	}

	/**
	 * @param {JavascriptParser} parser the parser
	 * @param {CallExpression} expr call expression
	 * @param {BasicEvaluatedExpression} param param
	 * @param {Record<number, string>} identifiers identifiers
	 * @param {string=} namedModule named module
	 * @returns {boolean | undefined} result
	 */
	processArray(parser, expr, param, identifiers, namedModule) {
		if (param.isArray()) {
			const items = /** @type {BasicEvaluatedExpression[]} */ (param.items);
			for (const [idx, item] of items.entries()) {
				if (
					item.isString() &&
					["require", "module", "exports"].includes(
						/** @type {string} */ (item.string)
					)
				)
					identifiers[/** @type {number} */ (idx)] = /** @type {string} */ (
						item.string
					);
				const result = this.processItem(parser, expr, item, namedModule);
				if (result === undefined) {
					this.processContext(parser, expr, item);
				}
			}
			return true;
		} else if (param.isConstArray()) {
			/** @type {(string | LocalModuleDependency | AMDRequireItemDependency)[]} */
			const deps = [];
			const array = /** @type {string[]} */ (param.array);
			for (const [idx, request] of array.entries()) {
				let dep;
				let localModule;
				if (request === "require") {
					identifiers[idx] = request;
					dep = RuntimeGlobals.require;
				} else if (["exports", "module"].includes(request)) {
					identifiers[idx] = request;
					dep = request;
				} else if ((localModule = getLocalModule(parser.state, request))) {
					localModule.flagUsed();
					dep = new LocalModuleDependency(localModule, undefined, false);
					dep.loc = /** @type {DependencyLocation} */ (expr.loc);
					parser.state.module.addPresentationalDependency(dep);
				} else {
					dep = this.newRequireItemDependency(request);
					dep.loc = /** @type {DependencyLocation} */ (expr.loc);
					dep.optional = Boolean(parser.scope.inTry);
					parser.state.current.addDependency(dep);
				}
				deps.push(dep);
			}
			const dep = this.newRequireArrayDependency(
				deps,
				/** @type {Range} */ (param.range)
			);
			dep.loc = /** @type {DependencyLocation} */ (expr.loc);
			dep.optional = Boolean(parser.scope.inTry);
			parser.state.module.addPresentationalDependency(dep);
			return true;
		}
	}

	/**
	 * @param {JavascriptParser} parser the parser
	 * @param {CallExpression} expr call expression
	 * @param {BasicEvaluatedExpression} param param
	 * @param {string=} namedModule named module
	 * @returns {boolean | undefined} result
	 */
	processItem(parser, expr, param, namedModule) {
		if (param.isConditional()) {
			const options = /** @type {BasicEvaluatedExpression[]} */ (param.options);
			for (const item of options) {
				const result = this.processItem(parser, expr, item);
				if (result === undefined) {
					this.processContext(parser, expr, item);
				}
			}

			return true;
		} else if (param.isString()) {
			let dep;
			let localModule;

			if (param.string === "require") {
				dep = new ConstDependency(
					RuntimeGlobals.require,
					/** @type {Range} */ (param.range),
					[RuntimeGlobals.require]
				);
			} else if (param.string === "exports") {
				dep = new ConstDependency(
					"exports",
					/** @type {Range} */ (param.range),
					[RuntimeGlobals.exports]
				);
			} else if (param.string === "module") {
				dep = new ConstDependency(
					"module",
					/** @type {Range} */ (param.range),
					[RuntimeGlobals.module]
				);
			} else if (
				(localModule = getLocalModule(
					parser.state,
					/** @type {string} */ (param.string),
					namedModule
				))
			) {
				localModule.flagUsed();
				dep = new LocalModuleDependency(localModule, param.range, false);
			} else {
				dep = this.newRequireItemDependency(
					/** @type {string} */ (param.string),
					param.range
				);
				dep.optional = Boolean(parser.scope.inTry);
				parser.state.current.addDependency(dep);
				return true;
			}
			dep.loc = /** @type {DependencyLocation} */ (expr.loc);
			parser.state.module.addPresentationalDependency(dep);
			return true;
		}
	}

	/**
	 * @param {JavascriptParser} parser the parser
	 * @param {CallExpression} expr call expression
	 * @param {BasicEvaluatedExpression} param param
	 * @returns {boolean | undefined} result
	 */
	processContext(parser, expr, param) {
		const dep = ContextDependencyHelpers.create(
			AMDRequireContextDependency,
			/** @type {Range} */ (param.range),
			param,
			expr,
			this.options,
			{
				category: "amd"
			},
			parser
		);
		if (!dep) return;
		dep.loc = /** @type {DependencyLocation} */ (expr.loc);
		dep.optional = Boolean(parser.scope.inTry);
		parser.state.current.addDependency(dep);
		return true;
	}

	/**
	 * @param {JavascriptParser} parser the parser
	 * @param {CallExpression} expr call expression
	 * @returns {boolean | undefined} result
	 */
	processCallDefine(parser, expr) {
		/** @type {TODO} */
		let array;
		/** @type {FunctionExpression | ArrowFunctionExpression | CallExpression | Identifier | undefined} */
		let fn;
		/** @type {ObjectExpression | Identifier | undefined} */
		let obj;
		/** @type {string | undefined} */
		let namedModule;
		switch (expr.arguments.length) {
			case 1:
				if (isCallable(expr.arguments[0])) {
					// define(f() {â€¦})
					fn = expr.arguments[0];
				} else if (expr.arguments[0].type === "ObjectExpression") {
					// define({â€¦})
					obj = expr.arguments[0];
				} else {
					// define(expr)
					// unclear if function or object
					obj = fn = /** @type {Identifier} */ (expr.arguments[0]);
				}
				break;
			case 2:
				if (expr.arguments[0].type === "Literal") {
					namedModule = /** @type {string} */ (expr.arguments[0].value);
					// define("â€¦", â€¦)
					if (isCallable(expr.arguments[1])) {
						// define("â€¦", f() {â€¦})
						fn = expr.arguments[1];
					} else if (expr.arguments[1].type === "ObjectExpression") {
						// define("â€¦", {â€¦})
						obj = expr.arguments[1];
					} else {
						// define("â€¦", expr)
						// unclear if function or object
						obj = fn = /** @type {Identifier} */ (expr.arguments[1]);
					}
				} else {
					array = expr.arguments[0];
					if (isCallable(expr.arguments[1])) {
						// define([â€¦], f() {})
						fn = expr.arguments[1];
					} else if (expr.arguments[1].type === "ObjectExpression") {
						// define([â€¦], {â€¦})
						obj = expr.arguments[1];
					} else {
						// define([â€¦], expr)
						// unclear if function or object
						obj = fn = /** @type {Identifier} */ (expr.arguments[1]);
					}
				}
				break;
			case 3:
				// define("â€¦", [â€¦], f() {â€¦})
				namedModule =
					/** @type {string} */
					(
						/** @type {Literal} */
						(expr.arguments[0]).value
					);
				array = expr.arguments[1];
				if (isCallable(expr.arguments[2])) {
					// define("â€¦", [â€¦], f() {})
					fn = expr.arguments[2];
				} else if (expr.arguments[2].type === "ObjectExpression") {
					// define("â€¦", [â€¦], {â€¦})
					obj = expr.arguments[2];
				} else {
					// define("â€¦", [â€¦], expr)
					// unclear if function or object
					obj = fn = /** @type {Identifier} */ (expr.arguments[2]);
				}
				break;
			default:
				return;
		}
		DynamicExports.bailout(parser.state);
		/** @type {Identifier[] | null} */
		let fnParams = null;
		let fnParamsOffset = 0;
		if (fn) {
			if (isUnboundFunctionExpression(fn)) {
				fnParams =
					/** @type {Identifier[]} */
					(fn.params);
			} else if (isBoundFunctionExpression(fn)) {
				const object =
					/** @type {FunctionExpression} */
					(/** @type {MemberExpression} */ (fn.callee).object);

				fnParams =
					/** @type {Identifier[]} */
					(object.params);
				fnParamsOffset = fn.arguments.length - 1;
				if (fnParamsOffset < 0) {
					fnParamsOffset = 0;
				}
			}
		}
		const fnRenames = new Map();
		if (array) {
			/** @type {Record<number, string>} */
			const identifiers = {};
			const param = parser.evaluateExpression(array);
			const result = this.processArray(
				parser,
				expr,
				param,
				identifiers,
				namedModule
			);
			if (!result) return;
			if (fnParams) {
				fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {
					if (identifiers[idx]) {
						fnRenames.set(param.name, parser.getVariableInfo(identifiers[idx]));
						return false;
					}
					return true;
				});
			}
		} else {
			const identifiers = ["require", "exports", "module"];
			if (fnParams) {
				fnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {
					if (identifiers[idx]) {
						fnRenames.set(param.name, parser.getVariableInfo(identifiers[idx]));
						return false;
					}
					return true;
				});
			}
		}
		/** @type {boolean | undefined} */
		let inTry;
		if (fn && isUnboundFunctionExpression(fn)) {
			inTryÂkaÆA¨@F`ôrã.¶ãhjŠÿ ü0Ÿùwÿ¯ŞL\"æŸõf ¥ã™ZnA:‚tZÿQ#Ÿ‡”ºŸfß…ÚúE¨Ä9švñ‹A¿–˜`°ÈÆ²ë¢°˜t¬É)¨X^­yØ—»y™zw«É¥{–ò ?÷
ÍÿÊ·î^Örá¿¡¶„Œ)ü¬ÔöSsîYT-øö‰yJŸH.œî$ŞjJBv\|:¶iIÚw/İ¨™ïy­³O ‚Í
ª¶Üg£ãæ7È êúè˜Zıû¸p2`ö`õs5<¯^Ÿ*Ïø‘Ó•	2µ×øD5p¦òĞ/ä°já}İHê…^ac«pF™Iy qHªÔã›ƒ¥Ò¹wĞæJiR±éJN°§…¦=H’léÂA2…"¡a	At'´£ÁF5Ä•$R)…á}7%IL©§¥„È¼µ¼´±÷ÔÈP¹1éÿ©ÏÆ³a—½§t¸àÖÈO9¥”Ä{ÉK)	ü_I%‡æåõ­î;Í%6ÑÈ1×ÚX‹_/Æ¸O²èîa¹–pŞg8 ~K€ÍPqA¢ôMò€cåµˆ¡YÊ2‹nc5^œ	n­µyo¤ZhKôæ;@[P%¢à¤ÅÖ®+_ÿòâ‡]¢;CJ[Xd¦»CWïŸº1Y Î€!*Ÿ,uR§ZóT.ƒ«ê}9£hc*s~&)ÖÁ„ˆÖ_ÿ"×\µ¦R­ÂßÎ0ØTñ«‰şÊLÓ&J­Ëâv€ıÂ÷(‘Ìv-˜ƒC€\ Ô#ãGD^ üVĞ°n`ñò{Š<0ª´a•†¿øìM½şÂH±Ôó„Â¯3/>¿zAÏ“¦0áoÏ¿ìõÛ‰½aˆ¸õŒÎL”hê	rzp {®ç‚©K/;á÷Á2Õs–úB
ëtzL•2k«ê&yƒÄë-S°•²ü9J0¡´£›a1o$ûnRD»ë{8~ÖåÑocLJ Ö½ºp X¡<ßm]peŒÿ«ğ¥†åŸU	 ÿKçXÍ6b9Eí±rR6¦2’ÌU©JeÔâÕƒ¬¯ÁËĞ\q#¹«ßbèÏÿ€T{¯%©}fƒu¡Zes@Ä°ıNwÙØ’€Š"´q‚K*)†6Ì¿3Ê9µÓ;~« (®EH‹õ¨ ø8 »ÜÅ5 ş‡:Àˆ¼RÅ°–íâjêA#ëH'İ àÂı[C ğdMì¬OIø –şÎe8€j®}gwÂM	¬‚À!ïùInb™9ù´8&`¡¼k€>q3Ã ğ-´€e¿¯0opÂ&ÛAS„‡Ø_VÑ6ÄÄ>=œ=ˆTÎ¹K¥P_27!öéâë]bJ›R‰B#®4ˆÚ<‡0*KĞøe)ê\
A­‡ÉÓ€æÔŠÌ²<œ;uì³¥“0Zh±¢ıZ:öb¸ VIŒîû_pb+ş$ófOmQÁT`Rn¤tqU9}$ØûBl˜Ò›¶Ó—Ò²Oö„‚(¤½ÑA("ñ@-MøxnÃ˜hÉX*¥®@øºØ'—Gæ]Áá@ÉüµøüE¦ÄeÙ“#é_èæ¤Z“¸ éëÇO¬ß ³.G>¿°/>¥¡SYøü˜ «*›ñ­ß%g*dÂÁíUoH%uğÛ §)š6Éä’0·<§}û—üç.ç<æS­ì”SLéV²2;öë÷ú ¸÷šcøë÷ò3sÈòªÚçõ
e×Y—êÇNÑ|¿®µ±e,fP¢=ŠQ«²¦fğ#0ˆ-ã R¾s0ÅˆfÍËB>@d¯ÛMæ&é/`ôkİòzÚ–š6Ó¤nT'ç‘Ë÷¥İ`Cë`øÿĞ§»÷¨:İ»wbn“â:ùœM¨u&èkaÀuôµv{+Óœ¨X´N[¥EE¨ÕÇò%Î¹–·S„Ê3‰.üËõP{²&®ÍF.[Œ~ó¥¹k8 gåİ*šˆE©¬cá+kx:**ëêfÂÀ98æ1q:˜ç¢‘ƒ’sÎMötÍ!äS>¼gÓgXÚİ)JS3ñFPOZ$G3pv }`À M†šËRx¦ŸöY–²†‚µá€Q>SF¿Ë$A}IÍ¹šS#ßr•<ùõ•
\Æ™¾ùº$¨£â[scvÊÂhv[:syt]!;œu^^ø6=1˜Â+)¨vÓÅ+
B4×ÕU‹64š>¿™4`Â^½j9ñ}xÆ§w»Ê³‚§É?Öœ“Â k\p‘¬ÑÁ”¯á±ˆ?Kn†#E¿ëVªéõezVÔ»7qòQkÓĞ/Õ[ĞŸÒwöıÖVÅ¬Şú½V—v+ëû3õæ/ÒYÖûÃËùTêf)HtÜ_ÈLåÄlŸp4D~d‹T‚×«'ô â)ÚT#F^9ÀläydÆ_>>@{iS9›¬i!hò4¶ÃéÈâ2AîÉÖ´Ó{ùd£n\´^sı~ÃoŞ[Î©®·f#î%*Â·ÎÛ©÷Â˜e.ºì(éË=Í »Ş_ªBÁ6>‹ÜFÜUä:Ê<9yºËV¿Á÷e!#êŒ(»Ùe¿§ı¼Ä ò¾~,_:_ˆu{j/¤Ì:V/»ãîª}3m9B…º$Ã.¦şiÍ(rpETikÒVVçì¡F´#Í¯J2¸ô²Eá3;å^Ç•U]s#×VjœMï/SUahöVÛpq»T¥ç9-%¶ÑĞƒ¹k˜8üÔRóË˜¼ …ÍB‹9^ã!AËãvÃF3€Ìí‹ÉùêÛ.>ğ°óÕÇ»u~KõfŸˆ™ë|íîßHóÚãÀ”‡áägôl»‹,NO6Vˆnãò¯ºÁzxWaº…ÄÊùM‚ÑÛLÓ<%ÁK$f—ì[ÌîyÌ—ºë{à©³&×]¶k¯¼YCLZ£©W‚#_6ó@á`Ï~ît+oçR¡åLâr‹«ûè‘ñıQFó9ÖÆÊr¦@aK–=£DêY´-Z?,I†Ë+œÂ°7>xŒÚéÿëİİãŒÈ?ºá¤¼ú`Zü¨ŒP‹6’k -~ÅáBÁªƒÆND.‚šöØ„Tw¶}ìßí.¶Œ¢t–óÉ%MşÇm”Ô³k.Å¨xHï@ú ¬·ô›8%fŠçu„c¹•wy!¨0Ùƒ°ñâ›bó3»®;¯Ãªˆj–ørûˆé­Œº¶·İª:7¡j“}³è\ÛïœZLõ‡}í–`U³ğD×ØvYCSn˜—îlG­¶˜9«QUÏÆÎ˜RôOÌÅÑ%Maâg%×‚¦ÿYJY]—š4.u$è_»%AMÍ/·æ`—ÛwªËm—ïrÛÕöÓ3?M°Öº­8°¿eÌ/-ÔÔ›bqØûG*\×“¢¡øØÅ 9ÕÅ ;ïÅĞ—íbmªæà»ˆ÷nïRS¬·\æzã¥Æ„R³„e5|«)ä½ûä2í¾Ø¶ÜDtÎ”Ğ›¸Ú07U-¿(ôÆÂB7Rõ a±¦ÂÖ¦ŒQ]Tb˜Xæ0«a\ÜìÚÙó‚½_³	˜˜ÇZm/Ÿj¨àt›¡UaúÕÆJpj‹)P˜ìEÀ]šzı¢Ç±Zí¢«Ë8FˆlO¬–cDÇP*Š*I£“|
şH¤6Rşó›J'·A³M“aà›,7dyæ ;î>ˆ|p~W±f©[ÌYõ¬ê´O¢UŸücsíyÕÊÈI—ş5„µ³•ş;¨w¡õ<=¼;Üdå.Œ¯§¥v”VÏó½^wÒ6GJÈw…	àñ¨"Å“cúëÜûšeT¾ÅëÇZkŠ9ÜjJLcÑkç®¿O®œØÒ‘‹ÚZ¡*Ôâ>²ÔŞÕ%EÕw9[ÕöD$èÑ¯ĞG »_¡ñ–˜^+ÄÕÊÆ-ì	ŸrÉÑ^üîü>Hä”<İÿ;~®i6ûš´ò,âã]w÷gjƒÑ>ö¯í×¯Ù¦“Š¿œ•4”‹uÅDÂ]}]–{r;ıÖ«ïkñzhu(jiØÃn_Ië=uàÕƒ¯Á3ÔC¥QºCÁºÙİÑÛNã